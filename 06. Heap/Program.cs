namespace _06._Heap
{
	internal class Program
	{
		/*************************************************************************************
         * 힙 (Heap)
         * 
         * 부모 노드가 자식노드보다 우선순위가 높은 속성을 만족하는 트리기반의 자료구조
         * 우선순위 큐를 구현?
         * 많은 자료 중 우선순위가 가장 높은 요소를 빠르게 가져오기 위해 사용
         * 메모리구조 힙이랑은 상관없다!
         *************************************************************************************/

		// <힙 구현>
		// 힙은 노드들이 트리의 왼쪽부터 채운 완전이진트리를 구조를 가지며
		// 부모 노드가 두 자식노드보다 우선순위가 높은 값을 위치시킴
		// 힙 상태를 만족하는 경우 가장 최상단 노드가 모든 노드 중 우선순위가 가장 높음
		//
		//               2
		//       ┌───────┴───────┐
		//       8               52
		//   ┌───┴───┐       ┌───┴───┐
		//   13      37      67      92
		// ┌─┴─┐   ┌─┘
		// 17  43  52


		// <힙 노드 삽입>
		// 1. 힙의 최고 깊이, 최우측에 새 노드를 추가
		//
		//               2
		//       ┌───────┴───────┐
		//       8               52
		//   ┌───┴───┐       ┌───┴───┐
		//   13      37      67      92
		// ┌─┴─┐   ┌─┴─┐
		// 17  43  52 (7)
		//
		// 2. 삽입한 노드와 부모 노드를 비교하여 우선순위가 더 높은 경우 교체
		//
		//               2                               2                               2
		//       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
		//       8               52              8               52             (7)              52
		//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
		//   13      37      67      92      13     (7)      67      92      13      8       67      92
		// ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
		// 17  43  52 (7)                  17  43  52  37                  17  43  52  37
		//
		// 3. 더이상 교체되지 않을때까지 과정을 반복
		//
		//               2                               2
		//       ┌───────┴───────┐               ┌───────┴───────┐
		//      (7)              52              7               52
		//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
		//   13      8       67      92      13      8       67      92
		// ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
		// 17  43  52  37                  17  43  52  37


		// <힙 노드 삭제>
		// 1. 최상단의 노드와 최하단 최우측 노드를 교체한 뒤 최우측 노드를 삭제
		//
		//              (2)                             (37)                           (37)
		//       ┌───────┴───────┐               ┌───────┴───────┐              ┌───────┴───────┐
		//       7               52              7               52             7               52
		//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>  ┌───┴───┐       ┌───┴───┐
		//   13      8       67      92      13      8       67      92     13      8       67      92
		// ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                  ┌─┴─┐   ┌─┘
		// 17  43  52 (37)                 17  43  52 (2)                 17  43  52
		//
		// 2. 교체된 노드와 두 자식 노드를 비교하여 우선순위가 더 높은 노드와 교체
		//
		//              (37)                             7                               7
		//       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
		//       7               52             (37)             52              8               52
		//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
		//   13      8       67      92      13      8       67      92      13     (37)     67      92
		// ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
		// 17  43  52                      17  43  52                      17  43  52
		//
		// 3. 더이상 교체되지 않을때까지 과정을 반복
		//
		//               7                               7
		//       ┌───────┴───────┐               ┌───────┴───────┐
		//       8               52              8               52
		//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
		//   13     (37)     67      92      13      37      67      92
		// ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
		// 17  43  52                      17  43  52


		// <힙 구현>
		// 힙의 완전이진트리(비어있는곳 없는) 특징의 경우 배열을 통해서 구현하기 좋음
		// 노드의 위치를 배열에 순서대로 저장
		// 노드가 위치한 인덱스에 연산을 진행하여 노드 이동이 가능
		// 
		// 부모로 이동         : (index - 1) / 2 // 이거 해보면 위치가 나온다고? 좌표값으로 이해하면 됨, 소수점은 버림
		// 왼쪽자식으로 이동   : 2 * index + 1
		// 오른쪽자식으로 이동 : 2 * index + 2
		//
		//        0
		//    ┌───┴───┐
		//    1       2       ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		//  ┌─┴─┐   ┌─┴─┐ =>  │0│1│2│3│4│5│6│7│8│9│
		//  3   4   5   6     └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		// ┌┴┐ ┌┘
		// 7 8 9


		static void Main(string[] args)
		{
			//응급실 
			//Queue<string> queue = new Queue<string>();
			

			//queue.Enqueue("환자1 - 감기(30년뒤)");
			//queue.Enqueue("환자2 - 타박상(60년뒤)");
			//queue.Enqueue("환자3 - 심장마비(1분)");
			////기준 갖고 먼저 처리하는걸 구현해야함. queue는 먼저 온사람이 먼저 처리되는 식이라 맞지 않음
			//// 그래서 우선순위 큐라는걸 사용

			//while (queue.Count > 0)
			//{
			//	Console.WriteLine(queue.Dequeue());
			//}

			// 일단 최소힙
			PriorityQueue<string, int> pq = new PriorityQueue<string, int>();

			pq.Enqueue("환자1 - 감기", 5);
			pq.Enqueue("환자2 - 타박상", 8);
			pq.Enqueue("환자9 - 심장마비", 1);
			pq.Enqueue("환자4 - 교통사고", 3);
			pq.Enqueue("환자5 - 탈모", 9);

			while (pq.Count > 0)
			{
				Console.WriteLine(pq.Dequeue());
			}
			// 지금은 숫자 작은 순인데 큰순으로 바꾸는건 어떻게?

			for (int i = 0; i < 3; i++)
			{
				Console.WriteLine(pq.Dequeue());
			}

			pq.Enqueue("환자6 - 심장마비", 1);
			pq.Enqueue("환자7 - 고통사고", 3);

			while (pq.Count > 0)
			{
				Console.WriteLine(pq.Dequeue());
			}

			// 힙을 통해서 우선순위 큐 구현할 수 있음
			// 우선순위 1이 여러개 있으면 거기에선 무작위
			// 왜 우선순위 큐라 안하고 힙이라고 하나? 힙은 딴데도 쓰니까
			// 일단 빠르다. 이게 장점
			// 큐랑 구현방식이 아예 다름
			// 디큐 하기전에 우선순위 알 수 있는 방법?? 기능중엔 없는듯?
			// 하강작업때나 상승작업때나 반절은 제외 되기때문에 연산 시간 줄일 수 있음
			// 하강작업은 둘중 작은걸 먼저, 이유는 힙상태 유지
			// 힙은 왼쪽아래부터 꽉꽉 채워 만들어줌. 그게 효율적이니까
			// 힙은 최악의 경우에도 O(log n)
			// 배열로 구현하면 list 씀
			// C#은 최소값으로 구현되있으니, 최대힙(내림차순) 구현하고 싶으면 우선순위에- 곱하는게 단순하다.
			// 안그러면 람다식써서 복잡해짐

			// 우선순위큐(힙)
			// 다음 -> 최상단
			// 추가 -> 마지막 노드 추가 후 상승반복
			// 삭제 -> 최상단 출력후 마지막과 교체해준뒤 교체한 노드를 하강반복

		}
	}
}
