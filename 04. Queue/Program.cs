namespace _04._Queue
{
	internal class Program
	{

		/******************************************************
         * 큐 (Queue)
         * 
         * 선입선출(FIFO), 후입후출(LILO) 방식의 자료구조
         * 입력된 순서대로 처리해야 하는 상황에 이용
         * 대기열, 순서처리, 작업대기열
         * 연속기 구현때 쓰고 싶다, 많이들 쓴다고 한다.
         ******************************************************/

		// <큐 구현>
		// 1. 배열 사용
		// 선입선출(FIFO), 후입후출(LILO) 을 구현하기 위해 배열을 생성하고 순차적으로 데이터를 배치
		//     ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  앞 │1│2│3│4│5│ │ │ │  뒤
		//     └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// - 삽입 -
		// 비어있는 가장 뒷쪽에 데이터를 배치
		//  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  │1│2│3│4│5│ │ │ │   =>   │1│2│3│4│5│6│ │ │
		//  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// - 삭제 -
		// 가장 앞쪽 데이터를 출력하고 빈자리를 채우기 위해 나머지 데이터를 앞당기기 진행
		//  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  │1│2│3│4│5│6│ │ │   =>   │2│3│4│5│6│ │ │ │
		//  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// - 문제발생 -
		// 큐의 삭제 과정시 나머지 데이터를 앞당겨야하는 N번의 작업 발생
		//  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  │1│2│3│4│5│6│ │ │   =>   │ │2│3│4│5│6│ │ │   =>   │2│3│4│5│6│ │ │ │
		//  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

		// C++은 그래서 연결리스트로 구현
		// C#은 노드기반 자료가 효율적이지 않아서 다르게 처리

		// 2. 전단 & 후단
		// 삽입 & 삭제 시 데이터를 앞당기지 않고 head와 tail을 표시하여 삽입할 위치와 삭제할 위치를 지정
		//
		// - 삽입 -

		// head = 다음에 꺼낼 위치
		// tail = 다음에 추가될 위치

		// tail 위치에 데이터를 추가하고 tail을 한칸 뒤로 이동
		//     h       t                h         t
		//     ↓       ↓                ↓         ↓      
		//  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  │ │2│3│4│5│ │ │ │   =>   │ │2│3│4│5│6│ │ │
		//  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// - 삭제 -
		// head 위치에 데이터를 추가하고 head을 한칸 뒤로 이동
		//     h         t                h       t
		//     ↓         ↓                ↓       ↓
		//  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  │ │2│3│4│5│6│ │ │   =>   │ │ │3│4│5│6│ │ │
		//  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// - 문제발생 -
		// 큐의 배열 마지막 위치까지 사용하는 경우 빈자리가 없어 저장 불가한 상황 발생
		//       h         t              h           t
		//       ↓         ↓              ↓           ↓
		//  ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		//  │ │ │3│4│5│6│7│ │   =>   │ │ │3│4│5│6│7│8│
		//  └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		// head tail 때문에 끝까지 쓰면 문제발생..
		// 그래서 순환배열로 해결


		// 3. 순환배열
		// 배열의 끝까지 도달하여 빈자리가 없을 경우 처음으로 돌아가서 빈공간을 활용
		//
		// - 마지막위치 도달시 -
		// 다시 가장 앞 위치를 사용하여 빈공간을 재활용
		//          h     t          t       h           
		//          ↓     ↓          ↓       ↓           
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │ │ │ │ │5│6│7│ │   =>   │ │ │ │ │5│6│7│8│
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// - 문제발생 -
		// tail이 head을 침범하는 경우 모든 공간이 비어있는 상황과 가득차 있는 상황을 구분할 수 없음
		// 
		//         th                       th       
		//         ↓↓                       ↓↓       
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │ │ │ │ │ │ │ │ │        │5│6│7│8│1│2│3│4│
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//   비어있는 경우             가득찬 경우

		// 4. 포화상태확인
		// head와 tail이 일치하는 경우를 비어있는 경우로 판정
		// tail이 head 전위치에 있는 경우를 실제로는 한자리가 비어있지만 가득찬 경우로 판정
		//         th                      t h       
		//         ↓↓                      ↓ ↓       
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │ │ │ │ │ │ │ │ │        │5│6│7│ │1│2│3│4│
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
		//   비어있는 경우         가득찬 경우(로 판정)

		// 더 큰 배열 만들어서 글로 이사가는 방법 채택함


		static void Main(string[] args)
		{
			Queue<int> queue = new Queue<int>();

			for (int i = 0; i < 5; i++)
			{
				queue.Enqueue(i);                       // 입력순서 : 0, 1, 2, 3, 4
			}

			Console.WriteLine(queue.Peek());            // 다음순서 : 0,
														// 스택에선 제일 나중에 넣은 거였지만 여기선 제일 먼저 넣은거

			for (int i = 0; i < 3; i++)
			{
				Console.WriteLine(queue.Dequeue());     // 출력순서 : 0, 1, 2
			}

			Console.WriteLine(queue.Peek());            // 다음순서 : 3

			for (int i = 5; i < 10; i++)
			{
				queue.Enqueue(i);                       // 입력순서 : 5, 6, 7, 8, 9
			}

			Console.WriteLine(queue.Peek());            // 다음순서 : 3

			while (queue.Count > 0)
			{
				Console.WriteLine(queue.Dequeue());     // 출력순서 : 3, 4, 5, 6, 7, 8, 9
			}
		}
	}
}
