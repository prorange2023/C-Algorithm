namespace _01._List
{
	internal class Program
	{
		/*******************************************************
         * 리스트 (List)
         * 
         * 런타임 중 크기를 확장할 수 있는 배열기반의 자료구조
         * 배열요소의 갯수를 특정할 수 없는 경우 사용이 용이
         * 크기를 확정해두는게 좋을땐 배열, 아닐땐 이거 쓰는거
         * 모든 기능 => List<T> 클래스 검색 봐라
         *******************************************************/

		// <리스트 구현>
		// 리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조
		// 리스트는 동작 중 크기를 확장하기 위해 포함한 데이터보다 더욱 큰 배열을 사용
		//
		// 크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 삽입> 이 원리 때문에 insert 보단 add를 권장
		// 중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행
		//      ↓                        ↓                        ↓
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│ │ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│A│3│4│ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 삭제>  이걸 알고 빠른 삭제 구현하는법 어케하는가?
		// 중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
		//      ↓                        ↓
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│A│3│4│ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│3│4│ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

		// <리스트 시간복잡도>
		// 접근    탐색    삽입    삭제
		// O(1)    O(n)    O(n)    O(n)

		// 리스트 치명적 단점 : 미리 받은 용량을 벗어나게 추가되면
		// <리스트 용량>
		// 용량을 가득 채운 상황에서 데이터를 추가하는 경우
		// 더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용
		//
		// 1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
		// 크기 = 8, 용량 = 8
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ ← A 추가
		// └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 2. 새로운 더 큰 배열 생성
		// 크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ ← A 추가  │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 3. 새로운 배열에 기존의 데이터 복사
		// 크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ ← A 추가  │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 4. 기본 배열 대신 새로운 배열을 사용
		// 크기 = 8, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
		// └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 5. 빈공간에 데이터 추가
		// 크기 = 9, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 시간복잡도>
		// 접근    탐색    삽입    삭제
		// O(1)    O(n)    O(n)    O(n)

		static void Main(string[] args)
		{

			// List를 제대로 이해하고 있으면 생성부터 필요한 크기를 미리 설정함
			// List 는 클래스라 힙에 저장

			List<int> list1 = new List<int>(1000000);
			//list1.Capacity;
			for ( int i = 0;  i < 100000; i++ ) 
			{
				list1.Add(i);
			}



			List<string> list = new List<string>();
			// 자료구조 사이즈가 늘수도 있고 줄수도 있는 유연한 자료구조
			// 크기가 안정해져있는 유연함이 장점

			// 왜 배열은 Length 고 list는 count 인가? 배열은 길이가 확정이지만 list 는 길이가 데이터 갯수랑 맞지 않는다.
			// List는 그래서 list.Capacity(용량)도 있음
			// 삽입
			list.Add("0번 데이터");
			list.Add("1번 데이터");
			list.Add("2번 데이터"); // O(1) 추가속도가 add가 확실히 빠름
			list.Insert(1, "중간 데이터1"); // O(n)
			list.Insert(3, "중간 데이터2");


			// 삭제
			list.Remove("1번 데이터");
			list.RemoveAt(1);


			// 접근
			list[0] = "데이터0";
			string value = list[0];


			// 탐색
			int indexOf = list.IndexOf("2번 데이터");
			int findIndex = list.FindIndex(x => x.Contains("중간"));

			//List<string> list = new List<string>();
			//
			//list.Add("0번데이터이니라");
			//list.Add("1번 데이터이니라");
			//list.Add("2번데이터이니라"); // 되도록 이거 쓰라는건 List 구조 알면 이유가 나옴
			//
			//list.Insert(1, "중간데이터 1번자리에 추가"); // 이렇게 있는거에 끼면 있는 자료를 뒤로 밀어버림
			//list.Insert(3, "중간데이터 3번자리에 추가");
			//
			//
			//list.Remove("1번 데이터이니라"); // O(n)인거 이해했지?했으리라 믿는다잉
			//list.RemoveAt(2);
			//
			//bool fail = list.Remove("1번 데이터이니라"); // 이렇게 없는거 지우래서 못지우면 반환값이 bool- false임
			//
			//list[0] = "수정된 0번 데이터"; // 
			//string text = list[2];
			//
			//int insdexof = list.IndexOf("4번째 데이터이니라"); // 있으면 찾아주고 없으면 -1 반환
			//
			// Deque 라는것도 있다리 C#엔 없다고 한다
		}
	}
}
